{"pages":[{"title":"About ikarus-999","text":"Intro. HE11ow World!!안녕하세요 노래, 음악, 작곡을 좋아하는개발자입니다 🕹공부하는게 즐거워서 개발을 시작하게 되었어요 💽I like studying 💻I Like Developing 🖥 Contacts 📫 EMAIL = next.forr@gmail.com","link":"/about/index.html"}],"posts":[{"title":"GAN프로젝트_try","text":"Style GAN toy 프로젝트StyleGAN의 특징 이미지를 Style의 조합으로 보고Generator의 각 Layer마다 Style 정보를 입히는 방식으로 이미지 합성이 때 각 Layer에서 추가되는 Style은 이미지의 Coarse Feature(포즈, 성별 등)부터Fine Detail(머리색, 피부톤 등)까지각기 다른 Level의 Visual 속성들을 조절 가능StyleGAN은 생각보다 안정적이고 높은 퀄리티의 이미지 생성 네트워크 구조(Module) GAN이란 어떤 것일까??? Instance Norm? Generator 구조 설명 왼쪽이 Traditional Network, 오른쪽이 이 논문에서 제안한 Style-gased Generator. 왼쪽 네트워크와 오른쪽에 Synthesis Network가 똑같은 구조를 갖고 있지만,이전 GAN에서는 Latent z를 바로 Input으로 넣어줬던 것과는 다르게,StyleGAN에서는 학습된 Constant, (w) 값을 입력으로 사용함. 새롭게 Mapping Network와 Noise가 추가됨.. W를 Feature에 매핑하는 경우W는 Z처럼 고정된 분포를 따르지 않음. Sampling density는 학습된 Piecewise Continuous Mapping f(z)(f는 Mapping Network 입니다)에 의해 정해짐. 따라서, Warping(틀어짐)이 많이 일어나지 않음.그렇기 때문에 Factors of variation은 더욱 Linear하고, Disentangled (얽히지 않음).이것이 바로 z를 곧바로 Feature에 매핑하는 것보다 w에 매핑하는 것의 장점입니다 기존의 Generator (a)는Input Latent Vector (z)가 직접 Convolution, Upsampling 등을 거쳐 이미지로 변환되는 구조. Style-based Generator (b) 의 경우,(z)가 Fully-connected Layer로 구성된 Mapping Network을 거쳐Intermediate Latent Vector (w) 먼저 변환. (w)는 Constant Tensor가 이미지로 변환되는 과정에서스타일을 입히는 역할을 수행. 다양한 스타일의 이미지를 생성. Style Transfer를 실시간으로 가능케하는 Adaptive Instance Norm Synthesis Network (합성 네트워크)z를 중간 latent space W에 매핑을 한 뒤에 이 w는 “A”를 거쳐서 style, y=(ys,yb)로 변형됨. 이때 A는 학습된 affine transform 임. 그리고 이 style들은AdaIN(adaptive instance normalization) opeartion을 control 함. AdaIN은 style transfer를 할 때 많이 쓰이는 방법으로, 임의의 style transfer를 실시간으로 가능하게 함.여기서 feature map xi는normalized 된 다음에, style로 변환된 두 y로 scaled, biased 됨. (style이 입혀짐)이 과정을 매 layer 마다 반복함. 그리고 이러한 방법은 scale-specific control 을 가능하게 함. To be continued…","link":"/2020/11/17/GAN%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-try/"},{"title":"fpost2","text":"머신러닝과 딥러닝의 차이머신러닝 머신러닝은 정형 데이터 표 형태의 데이터 딥러닝은 비정형 데이터 그림, 사진, 오디오 형태의 자연 데이터 머신러닝 기초 준비물 충분한 용량(RAM 32GB++, SSD 512GB++, i7-10Gen++)의 데스크탑 권장! 가장 먼저 파이썬, 텐서플로우 를 설치합니다. 설치 버전 확인!! 매우 중요합니다! 파이썬 텐서플로우 넘파이 &amp; 싸이킷런 파이썬 버전을 여러개 설치 가능합니다. 이때는 환경 변수, IDE 경로 셋팅이 중요합니다. 윈도우라면 CMD보다는 powershell을 쓰는것이 편합니다. 제일 쉬운 방법은 아나콘다🛎… 하지만 용량이 큽니다. 써본 결과 리눅스에 도커가 최적 환경입니다⚙️. 추후 포스팅 예정 입니다.📯 Lets Burn the GPU!!🔥🔥🔥(TF2.0 wow!!)123456789101112131415161718192021import sysimport numpy as npimport tensorflow as tffrom datetime import datetime# tensorflow 실행모드를 확인합니다print(tf.executing_eagerly())shape = (int(10000), int(10000))startTime = datetime.now()with tf.device(&quot;/gpu&quot;): random_matrix = tf.random.uniform(shape=shape, minval=0, maxval=1) dot_operation = tf.matmul(random_matrix, tf.transpose(random_matrix)) sum_operation = tf.reduce_sum(dot_operation)result = sum_operationprint(result)print(&quot;\\n&quot; * 2)print(&quot;Time taken:&quot;, datetime.now() - startTime)print(&quot;\\n&quot; * 2)","link":"/2020/10/24/fpost2/"},{"title":"firstpost1","text":"HEXO 블로그 설치와 사용법새 글 쓰는 법1$ hexo new [레이아웃이름] &quot;새 포스트이름&quot; 레이아웃 디폴트(바로 발행) : post 바로 발행되지 않는 글 : draft 1$ hexo publish &quot;새 포스트이름&quot; 으로 draft에서 publish 합니다. publish는 잘 쓰지 않는다 파일명 에러나기 때문. 그냥냅다 MarkDown으로 쓰고 hexo g -d로 해버림","link":"/2020/10/24/firstpost1/"},{"title":"TF2","text":"Tensorflow 2.x 사용법Tensor 생성 tf.constant() : list, tuple, Array 를 Tensor로 바꿈 tensor = tf.constant(arr) tensor.dtype : 데이터 타입 확인 tf.cast(tensor, dtype=tf.uint8) : TF int8로 데이터타입 바꾸기 tensor.numpy() : numpy array로 바꾸기 Tensor에 랜덤한 숫자들 생성 numpy에서는 기본적인 normal distribution 생성np.random.randn(9) : 9개의 불연속적이며 일정한 분포 난수 생성 Distribution에 따른 난수 생성 tf.random.normal중심극한 이론에 의한 연속적인 모양 tf.random.uniform불연속적이며 일정한 분포","link":"/2020/11/22/TF2/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/10/24/hello-world/"},{"title":"fpost3","text":"일상을 끄적이다 - Mel Spectrogram 자동 분석을 위한 test page 입니다.M2U - March Of Fear비탄으로 가득 찬 이 도시 안에 떨어지는 Melody, 감정을 연기하는 춤추는 Endless rain… 거짓말로 얼룩진 관계들 속에 웃을 수 있는 거야? 세계를 노래하는 The March of Fear. We live in the tragedy! 유명한 비극과 같은 잔혹한 세계 속에 우리는 웃음짓고 있어. 이 세계를 비웃는 고결한 수호자들에게 지켜낼 것들은 두려웠던 자신뿐이니까! 숨을 멈춘 사람들 속에서 청명하게 울려퍼지는 Aria… 병든 마음으로 가득찬 이 세계에 폭격을 날려! 지금 웃고 있는 너도 Sociopath, 알잖아? 우리는 이 곳에 생명이 깃든 포성을 던져! 에픽세븐 OST 「Promise」깊은 절망 속에 갇혀 쓰러져 가는 나의 두 손을가만히 잡아 준 따스한 너의 온기를 아직난 기억해Now I can hear you눈을 감으면손 끝에서 널 느껴Now I can hear youI can find you이젠 알 수 있어 약속해 Promise I promise 잊지 않을게우리 함께 나눈 약속들을Promise I promise 어둠을 지난N 번째 하늘 아래 이곳에끝이 보이지 않아도 때론 지쳐서 주저 앉아도약속해 희망을 우리 마음에 간절히 모아빛을 향해Now I can hear you눈을 감으면손 끝에서 널 느껴Now I can hear youI can find you이젠 알 수 있어약속해 Promise I promise 잊지 않을게우리 함께 나눈 약속들을Promise I promise 어둠을 지난N 번째 하늘 아래 이곳에 다시 시작된 시간 다시 걸어가는 길함께하기에 나는 빛날 수 있어멀리 조금씩 보여 따뜻한 파란 빛이우리 마음을 여기에 모아 시작해 한번 더 약속해 Promise I promise 잊지 않을게우리 함께 나눈 약속들을Promise I promise 어둠을 지난N 번째 하늘 아래 약속들을 Promise I promise 어둠을 지난N 번째 하늘 아래 이곳에 Mel Spectrogram 분석 중인 음악입니다. GPU와 스토리지 지원좀 부탁드립니다.","link":"/2020/10/26/fpost3/"},{"title":"training_pc","text":"딥러닝 공부 후기 비정형 데이터를 다룰려면 GPU는 필수다. Why GPU ?? CPU보다 더 빠른 병렬 처리 가능 행렬곱 계산이 CPU보다 훨씬 빠름 계산 그래프 빌드, 처리 속도가 빠름. 비정형 데이터 처리엔 GPU가 필수 음성 딥러닝, 나도 해볼까?음성 딥러닝 음성 딥러닝은 결코 쉽지 않다. 딥러닝계의 보스급.신호처리 배워야 그나마 수월하다.초반 Feature Extraction 경험을 쌓는것을 권장한다.RNN계열의 LSTM으로 시작. 하지만,Attention, Transformer 날코딩 등 논문 구현 경험이 매우 중요하다.Mel Spectrogram을 한다 해도 원리를 잘 알아야 나중에 모델링과 데이터 분해가 쉽다. 딥러닝 입문 방법딥러닝 입문 하려면 수학은 필수. 정말 중요. 논문 구현 시도해보기1논문 구현 시도해보기2 어떤 논문에는 파라미터 하나도 없는 것도 있다.레이어 구조도만 있고 파라미터가 없는 것은 진짜 구현난이도 보스급. 딥러닝 자격증 취득 후기이것이 바로 딥러닝 자격증!! 문제 유형 Category 1: Basic model Category 2: Model from learning dataset Category 3: Image classificationConvolutional Neural Network with real-world image dataset Category 4: Natural language processing (NLP)NLP Text Classification with real-world text dataset Category 5: Time series, sequences and predictionsSequence Model with real-world numeric dataset 이 시험은 응시자가 TensorFlow 2.x를 통해 모델을 빌드하여 문제를 해결할 수 있는지테스트합니다. 머신러닝(ML) 및 딥러닝의 기본 원칙 TensorFlow 2.x에서 ML 모델 개발하기 심층신경망 및 합성곱 신경망(CNN)을 통한 이미지 인식, 객체 탐지, 텍스트 인식 알고리즘 빌드 컴퓨터가 정보를 ‘보는’ 방식과 플롯 손실 및 정확도 이해할 수 있도록 다른 크기 및 형태의 실제 이미지를 활용하여 합성곱에서 이미지의 경로를 시각화 과적합을 예방하기 위한 확장 및 드롭아웃과 같은 전략 탐색 TensorFlow를 이용하여 자연어 처리 문제를 해결하기 위해 신경망 적용 Google 공식 페이지 발췌 합격 점수 / 규칙 허용된 인터넷 브라우징은 Tensorflow document, 총 100점 만점에 90점 커트라인 난이도는 category 5가 가장 높음 시험 시간 : 5시간 (컴퓨터 딥러닝 훈련시간 포함) 따면 좋은 점 개발자 네트워크에 join 할 수가 있어요~ 자격증 네트워크 참고문서 그럼 20000~!","link":"/2020/11/16/training-pc/"},{"title":"딥러닝 입문과 준비","text":"딥러닝 시작해보기Tensor 이해하기 차원 0차원(상수) : Scalar값 1차원(리스트 씌운 상수), 2차원(2d), 3차원(3d), 4차원(4-d), n차원(n-d) : Tensor Numpy로 Tensor 표현과 응용이 가능 123456import numpy as nparr = np.array([[3, 6, 9], [2, 4, 8]])print(arr.dtype) # dtype('float64')print(arr.shape) # (2, 3)print(arr.size) # 2 * 3 = 6 차원 늘리기와 줄이기 reshape, -1 활용 123arr.reshape(-1) # 1차원으로 펼치기arr.reshape(-1, 3) # 첫번째 차원은 알아서, 두번째 차원은 shape 3 Ravel() : arr의 차원을 1로 바꿈(==&gt; Flatten) 123arr = np.array([[1, 2, 3], [4, 5, 6]]) # (2, 3)arr.ravel()arr.shape #(6, ) np.expand_dims() : 값을 유지하고 차원만 늘릴때 12arr = np.expand_dims(arr, -1) #(6, 1)arr.shape numpy array를 빠르게 채우는 방법! 1234567891011121314# 0으로 채우기arr2 = np.zeros([3, 4]) # 3 * 4의 0이 채워진 배열one2 = np.ones([3, 4]) # 3 * 4의 1로 채워진 배열five2 = np.ones([3, 4]) * 5 # 1로 채운 값에 5를 다 곱함arr2 = np.arange(n, m) # n ~ m-1까지의 수로 배열 채우기# array([n ~ m-1])arr = np.arange(5, 11).reshape(2, -1) # 5 ~ 10 : 6개의 숫자, (2, 3)arr # array([5, 6, 7] # [8, 9, 10]) 모양이 맞지 않으면 Error…5, 6, 7, 8, 9는 5개의 숫자5 * 1 만 가능한. Index &amp; slicing 123456789101112131415# 리스트 인덱스 &amp; 슬라이싱nums = [2, 3, 4, 5, 6]nums[:-1] # 마지막 숫자 전까지 표시nums[::-1] # 리스트 안의 숫자를 거꾸로 표현nums = [[1, 2, 3], 4, 5, 6, 7]print(nums[0][1]) = 2 # 첫번째 리스트 안의 인덱스가 1인 숫자arr = np.array([5, 6, 7], [8, 9, 10])print(arr[1, 2]) # 10 --&gt; 인덱싱 [행, 열]print(arr[1:, 1:]) # [[9, 10]] Boolean Indexing1234data = np.random.randn(3, 3)print(data&lt;=0) # False, True로 나옴data[data &lt;=0] = 1 # 0 이하인 것을 1로 채우다","link":"/2020/11/22/%EB%94%A5%EB%9F%AC%EB%8B%9D-%EC%9E%85%EB%AC%B8%EA%B3%BC-%EC%A4%80%EB%B9%84/"},{"title":"딥러닝 입문과 준비2","text":"딥러닝 시작해보기-2Broadcast두개의 행렬 shape가 서로 달라도한쪽의 차원이 같거나, 연산하는 값이 한 개일때shape에 맞게 복사해서 연산함 123456789101112131415161718192021arr = np.arange(6).reshape(-1, 3)# [[0, 1, 2], # [3, 4, 5]]arr + 3# [[3, 4, 5],# [6, 7, 8]]arr * 3# [[0, 3, 6],# [9, 12 15]arr + np.array([1, 2, 3])# [[1, 3, 5],# [4, 6, 8]]np.add(arr, 1)# 모든 원소에 1을 더함np.multiply(arr, 3)# 모든 원소에 3을 곱함 argmax, argmin 배열의 큰 값이나 작은 값의 index return 1234arr = np.array([1, 4, 6, 54, 3, 2])np.argmax(arr) # 54np.argmin(arr) # 1np.unique(arr) # 유일한 값 출력","link":"/2020/11/22/%EB%94%A5%EB%9F%AC%EB%8B%9D-%EC%9E%85%EB%AC%B8%EA%B3%BC-%EC%A4%80%EB%B9%842/"},{"title":"딥러닝-입문과-준비3","text":"딥러닝 시작해보기-3차원수 늘리기, 줄이기(TF2.x)1234567x = tf.expand_dims(x, 1)x.shape # (x.shape, 1)x[..., tf.newaxis].shape # (x.shape, 1)np.squeeze(x[0]).shape # x.shape 차원 줄이기 TF2.x LayersConvolution filters : layer에서 출력될때 몇개의 filter kernel_size : filter(weight) 의 사이즈 strides : 몇 개의 pixel만큼 skip하면서 sliding window 할 것인지 padding : same, zero activation : 활성화 함수(Linear function은 층을 쌓는 의미가 없다) to be Continued…","link":"/2020/11/23/%EB%94%A5%EB%9F%AC%EB%8B%9D-%EC%9E%85%EB%AC%B8%EA%B3%BC-%EC%A4%80%EB%B9%843/"},{"title":"딥러닝-입문과-준비4","text":"딥러닝 시작해보기-4인공신경망과 손실함수 인공신경망의 기본 구조 뇌의 학습방법을 수학적으로 모델링한 기계학습 알고리즘 기본 구조 : y = Wx+b\\(x_i\\) : 입력, \\(w_i\\): 가중치, b : bias, f: 활성화함수u : 결합(Net), z: 출력 뉴런에는 선형 결합과 활성화 함수 기능이 들어있음 입력층, 은닉층, 출력층으로 구성됨 각 노드의 뉴런 출력은 직접 전달되는 정보에만 의존할 뿐 다른 노드와는 무관 그래서? 병렬처리가 가능함. 손실 함수(Loss or Cost function) 신경망의 출력값과 실제 결과값의 차이를 정의하는 함수 신경망 학습목표는 손실함수를 최소화 하는 방향으로 움직여야 함 SGD, Adam 등의 학습 최적화 알고리즘 손실 함수 회귀(Regression)제곱 오차(MSE) 사용, 최근에는 rmse, mae의 장점이 있는 Huber Loss 사용하는 추세 Huber Loss?MAE + MSE -&gt; for Time Series Data!! 분류(Classification)활성화 함수 : softmax, 손실함수 : cross-entropy 알고리즘과 역전파 학습 알고리즘 경사 하강법: 기울기를 이용하여 손실함수 S(\\theta) 값을 최적화 gradient(기울기)의 반대 방향으로 일정 크기만큼 이동하는 것을 반복하여손실함수의 값을 최소화하는 \\theta의 값을 찾음 \\[\\theta = \\theta - \\eta \\nabla_\\theta S(\\theta)\\] 이 떄 \\eta 는 미리 정해진 learning rate(step size) 이고 보통 1e-3 ~ 1e-4 정도를 사용 역전파 계산 그래프 노드는 연산을, 엣지는 데이터의 흐름방향 sigmoid 함수 역전파 합성함수 미분법(Chain Rule) 행렬연산과 역전파 1 이진분류 2-layer NN 역전파 to be continued…","link":"/2020/11/24/%EB%94%A5%EB%9F%AC%EB%8B%9D-%EC%9E%85%EB%AC%B8%EA%B3%BC-%EC%A4%80%EB%B9%844/"},{"title":"딥러닝-입문과-준비6","text":"딥러닝 시작해보기-6💥Remind!! 딥러닝에 비선형 활성화 함수를 사용하는 이유 선형 함수로는 XOR과 같은 non-linear한 문제는 해결이 안됨;; 그러면 Hidden Layer를 늘리면 되지 않을까? $$f(ax+by) = af(x) + bf(y)$$ 라는 특징 때문에 N-layer 깊이를 아무리 쌓아도 1-Layer로 동작함. 최적화(Opt) 알고리즘 경사하강법(GD)$$\\theta = \\theta - \\eta \\nabla_\\theta S(\\theta)$$ Network의 parameter=$$\\theta $$ 로 할때 손실함수 $$J(\\theta)$$의 값을 최소화하기 위해 기울기$$\\nabla J(\\theta)$$를 이용하는 방법GD에서는 Gradient의 반대 방향으로 일정 크기(lr)만큼 이동하는 것을 반복하여 loss function의 값을 최소화 하는 $$\\theta$$의 값을 찾음, lr $$\\eta$$ 는 보통 1e-3 ~ 1e-4 사이에서 사용함.너무 크면 global minimum을 지나치고 너무 작으면 Local Minimum에 빠짐. 확률적 경사하강법(SGD)전체 Training set을 사용하는 것을 batch Gradient Descent, 계산량이 많아지는 것을 방지하기 위해mini-batch에 대해서만 손실함수를 계산하는 확률적 GD를 사용함.같은 시간에 더 많은 step를 갈 수 있음, 여러번 반복할 경우 batch의 결과와 비슷함 GD vs SGDGD : 확실한데 너무 느림 | SGD : 조금 헤메지만 빠름 Momentum : 현재 Gradient를 통해 이동하는 방향과 별개로 과거의 이동방식을 기억하면서 일종의 관성을 주는 방식 AdaGrad(Adaptive Gradient) 많이 변화했던 변수들은 step size를 작게 하는 것자주 등장하거나 변화를 많이 한 변수들은 optimum에 가까이 있을 확률이 높기 때문에 작은 크기로 이동하면서 미세조절 적게 변화한 변수들은 많이 이동해야할 확률이 높기 때문에 먼저 빠르게 loss값을 줄이는 방식으로 이동하는 방식학습을 계속 진행하면 step size가 너무 줄어드는 단점이 있음. RMSProp합을 지수평균으로 대체하여 Adagrad의 단점을 해결G가 무한정 커지지는 않으면서 최근 변화량의 변수간 상대적인 크기 차이는 유지할 수 있음. AdamMomentum + RMSProp 지금까지 계산해온 기울기의 지수평균을 저장 rmsprop과 유사하게 Gradient의 제곱값의 지수평균을 저장 Overfitting(과적합) Training Set의 지엽적인 특성까지 반영해 Variance High로 Training되어서 Training Set을 암기해버리는 현상 Test Set을 잘 예측하지 못함 주로 표현력이 높은 모델, 즉 파라미터가 많은 모델에 발생 정규화(Regularization) 손실함수에 가중치의 크기를 포함 가중치가 작아지도록 학습한다는 것은 Outlier(Noise)의 영향을 적게 받음 L2 정규화 Rigde Regression L1 정규화Sparse Model에 알맞음.. 작은 가중치들이 거의 0으로 수렴하여 몇개의 중요한 가중치들만 남음. Lasso Regression 미분 불가능한 점이 있기 때문에 Gradient-Base Learning에는 주의.. DropOut각 레이어의 일정 비율로 뉴런의 출력 값을 0으로 만들어 나머지 뉴런들로 학습하는 방법과적합을 효과적으로 예방 가능(Network 내부의 Ensemble 학습으로 볼 수 있음) 역전파는 ReLU처럼 동작Forward Propagation때 시그널을 통과시킨 뉴런은 Backward때도 통과시킴drop된 뉴런은 Backward Propagation때도 시그널 차단 반면, TEST때는 모든 뉴런에 신호를 전달함 Batch Normalization학습하는 이전 층의 파라미터 변화로 현재층의 입력 분포가 바뀌는 현상을 내부 공분산 변화(Internal Covariate Shift)이전 층의 작은 파라미터 변화가 증폭되어 뒷 레이어에 큰 영향을 받음.그래서… BN(2015) Gradient Vanishing, Exploding을 방지하는 대표적인 방법 직접적인 방법임. Training 과정 자체를 안정화시켜 학습속도를 가속화 평균과 분산을 조절하는 과정이 NN 안에 포함 되어 있다는 것이 핵심적 Training할때각 Mini Batch마다 $$\\gamma$$ 와 $$\\beta$$를 구하고 저장해 둠 Test할때구했던 $$\\gamma$$ 와 $$\\beta$$의 평균을 사용 Data Augmentation일종의 Regularization작업, 데이터가 적을 때 사용하면 매우 효과적즉 데이터 변형","link":"/2020/11/27/%EB%94%A5%EB%9F%AC%EB%8B%9D-%EC%9E%85%EB%AC%B8%EA%B3%BC-%EC%A4%80%EB%B9%846/"},{"title":"딥러닝-입문과-준비5","text":"딥러닝 시작해보기-5선형대수 배워보기(행렬을 아무리 곱하고 더해도 선모양)Scala : 크기만 존재하는 양Vector : 속도, 위치이동, 힘, 공간뒤틀림과 같이 크기와 방향이 모두 존재하는 양 Norm ? n차원 벡터 $$\\vec{x} = (x_1, x_2, \\cdots x_n)$$Norm $$\\lVert x \\rVert = \\sqrt{x_1^1 + x_2^2 + \\cdots + x_n^2}$$ “원점 O에서 점\\(x_1, x_2, \\cdots, x_n\\) 까지의 거리” 내적 ? Inner product, Dot product행렬끼리 곱할 때는 차원을 주의한다. A(m, n) * B(n, m) 만 가능 Transpose: 전치행렬(행과 열을 뒤바꿈) A.T numpy 연산(Element-wise operation) np.dot(x, y) (aka 내적, dot-product)와 x * y(element-wise)는 서로 다름. numpy 비교, 논리연산(element-wise operation)numpy Reductions argmax() : 최대값있는 인덱스를 리턴, argmin() : 최소값의 인덱스 리턴 np.all, np.any? ALL : Array내 모든 값이 TRUE인가? any : Array내 값이 하나라도 TRUE인가? np.mean, np.median, np.std 등 통계함수 사용 가능딥러닝에 대한 환상 복잡한 문제도 층을 깊고 넓게 쌓으면 해결된다 –&gt; Gradient Vanhshing, Initialize fault 으하하핰ㅋㅋㅋ $$Sigmoid(z) = \\frac{1} {1 + e^{-z}}$$Sigmoid 도함수의 최대값은 1/4 … –&gt; 그래서 Gradient Vanishing 나는거임 ㅇㅇ 가중치 초기화 초기화의 중요성$$t = wx+b$$ 에서 w가 100, b가 50이라면 x가 0.01이더라도 t는 51이 됨역전파때 sigmoid 함수 통과시키면 $$\\sigma’ (51)$$ 리턴됨하지만 t가 5만 넘어도 $$\\sigma (t)$$ 는 0에 수렴 –&gt; 이것이 바로 Gradient Vanishing… 그래서 입력층의 가중치w를 모두 0으로 리셋!Forward Propagation때 두번째 층 뉴런에 모두 같은 값이 전달됨Backward Propagation때 두째 층 가중치가 모두 똑같이 업데이트 ==&gt; 신경망 표현력 제한 Bias는 0으로 초기화하는게 일반적으로 효율적 가중치 초기화 2 표준 정규분포를 이용한 가중치 초기화Sigmoid함수의 출력값이 극단적으로(0 or 1)에 치우치는 현상 –&gt; Gradient Vanishing 표준편차를 0.01로 하는 정규분포로 초기화가중치가 모여 있음 =&gt; 기울기 소실 문제 어느정도 완화됨 가중치 초기화 3 Xavier초기화 방법(2010) 1w = np.random.randn(n_input, n_output) / (n_input) ** 0.5 Sigmoid와 같은 S자 함수의 경우 출력값들이 정규분포 형태이어야 안정적 학습 가능 Sigmoid function과 Xavier Init방법을 사용했을 경우 그래프 ReLU 계열 함수에는 적절하지 않음layer를 거쳐갈 수록 0에 수렴(converge) 가중치 초기화 4He 초기화 방법(2015) 1w = np.random.randn(n_input, n_output) / (n_input / 2) ** 0.5 RELU + He init –&gt; 10 layer를 거쳐도 표준편차가 0으로 수렴하지 않음 Summary 가중치 초기화는 너무나 중요함 tanh의 경우 Xavier Init 방법이 효율적 ReLU계열 함수에는 He Init 방법이 효율적 최근엔 대부분 He Init를 주로 사용","link":"/2020/11/25/%EB%94%A5%EB%9F%AC%EB%8B%9D-%EC%9E%85%EB%AC%B8%EA%B3%BC-%EC%A4%80%EB%B9%845/"}],"tags":[{"name":"ML","slug":"ML","link":"/tags/ML/"},{"name":"DL","slug":"DL","link":"/tags/DL/"},{"name":"GAN","slug":"GAN","link":"/tags/GAN/"},{"name":"HEXO","slug":"HEXO","link":"/tags/HEXO/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"Tensorflow2","slug":"Tensorflow2","link":"/tags/Tensorflow2/"},{"name":"TF2","slug":"TF2","link":"/tags/TF2/"},{"name":"Music EDA","slug":"Music-EDA","link":"/tags/Music-EDA/"},{"name":"Script","slug":"Script","link":"/tags/Script/"},{"name":"Linear Algebra","slug":"Linear-Algebra","link":"/tags/Linear-Algebra/"}],"categories":[{"name":"Machine Learning","slug":"Machine-Learning","link":"/categories/Machine-Learning/"},{"name":"GitPage","slug":"GitPage","link":"/categories/GitPage/"},{"name":"ilsang","slug":"ilsang","link":"/categories/ilsang/"},{"name":"Hexo","slug":"GitPage/Hexo","link":"/categories/GitPage/Hexo/"},{"name":"Music","slug":"ilsang/Music","link":"/categories/ilsang/Music/"}]}